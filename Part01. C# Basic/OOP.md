## C# 객체지향

### 객체
객체란 속성(= 변수)과 기능(= 함수)로 이루어진 단위로, 객체지향의 기본이 되는 단위이다.<br>
이러한 구조는 struct와 유사한데, 기본 접근 방식에서 struct와 큰 차이를 보인다. struct의 경우 기본 접근이 복사값이기 때문에 실제 값을 변경하려면 Ref 키워드를 이용해 접근해야 하지만 객체는 기본 접근이 Ref이기 때문에 다른 함수에서 그 값을 조작하면 실제 값을 조작하게 된다. 사실상 Object obj1 = new Object(); 라 할 경우 obj1 자체가 주소값이라고 보면 이해가 편하다. 

#### 생성자
객체 Object 내부에 반환 type 없이 Object() { ... }를 정의하면 이는 생성자를 의미한다. 생성자는 new를 이용해 객체를 생성할 때 호출되는 함수이며, 오버로딩도 가능하다. 오버로딩할 때 생성자 옆에 ": this()"를 붙이면 기본 생성자를 우선 실행 후 오버로딩한 생성자를 실행한다.

### 객체의 3요소

#### 상속성
부모 객체의 속성을 자식 객체에 물려주는 것을 의미한다. 부모 자식의 연결은 객체를 생성할 때 `: Parent`를 붙이면 된다. <br>
##### base
부모 객체의 값에 접근할 때엔 base 키워드를 사용한다. 대표적으로 부모 생성자에 접근할 땐 `Child : base(hp)` 같이 하면 된다.

##### 형변환
Parent type으로 선언된 변수 자리에 Child type을 넣으면 기본적으로는 Parent type으로써 인식한다. 따라서 Child만의 속성을 사용하고 싶다면 이를 Child type으로 형변환해줄 필요가 있다. <br>
가장 나이브한 접근으로는 `(Child)parent.get_child_props();`와 같이 강제로 형변환하는 방법이 있는데, 이 경우 parent가 실제 Child type이 아니면 에러로 인해 Crash가 발생하기 때문에 안정적이지 않다.<br>
안전한 접근으로는 **is**, 또는 **as** 키워드를 사용하는 방법이 있다. `parent is Child`는 parent가 Child type인지를 확인하여 bool type으로 반환한다. 따라서 Child인지를 확인 후 그에 따른 접근을 하게 되면 Crash가 발생하지 않는다. `parent as Child`는 좀 더 강화된 문법으로, parent가 Child라면 Child로 형변환된 parent를, 아니라면 NULL을 반환하는 문법이다. 따라서 if 문으로 `parent is Child`를 판단하지 않고 바로 `Child c = (parent is Child);`와 같이 바로 값을 담을 수 있다. 

#### 은닉성
객체의 속성을 private 한정자로 숨기는 것을 의미한다. 이는 외부에서 객체의 주요 속성에 접근하는 것을 방지한다. private로 숨긴 변수들은 public인 getter와 setter로 접근시키는데, 이 경우 외부에서 객체 속성에 접근하는 것을 허용하지만, 코드 상에서 객체 속성에 접근한 코드를 찾기가 수월하다는 장점이 있다. <br>
private와 public 외에 protected라는 한정자도 있는데, protected는 기본적으로 private이되, child에게만 접근을 허용하는 한정자이다.

#### 다형성
부모-자식 관계에서 하나의 함수에 대해 오버라이딩을 허용하는 특성을 의미한다. 부모에서 Virtual로 정의한 함수들은 자식에서 Override 키워드를 추가하여 별개의 동작으로 구현이 가능하다. 오버라이드한 자식 함수에서도 base 키워드를 통해 부모의 원본을 사용 가능하다. <br>
반대로 sealed 키워드를 사용할 경우 자식이 이 함수를 오버라이드 할 수 없다.
